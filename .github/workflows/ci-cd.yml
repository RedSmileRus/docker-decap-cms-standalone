name: Secure DevSecOps Pipeline for Decap CMS (Yandex Cloud)
on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:
permissions:
  contents: read
  security-events: write
  pull-requests: write
jobs:
  # ---------- SAST ----------
  sast:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # Gitleaks через Docker, без заглушки
      - name: Run Gitleaks (via Docker)
        run: |
          docker run --rm \
            -v "$PWD:/work" ghcr.io/gitleaks/gitleaks:latest detect \
            --source="/work" \
            --redact --verbose --exit-code=2 \
            --report-format sarif \
            --report-path "/work/gitleaks-results.sarif"
      # Установка Python для Semgrep
      - name: Set up Python for Semgrep
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install Semgrep CLI
        run: pip install --upgrade semgrep
      - name: Run Semgrep (SARIF)
        run: semgrep scan --config auto --sarif-output=semgrep.sarif
      # Установка Node.js
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      # Установка зависимостей, только если есть package.json
      - name: Install dependencies (if package.json exists)
        run: |
          if [ -f package.json ]; then
            npm ci
          else
            echo "skip npm install (no package.json)"
          fi
      # npm audit, только если есть package.json
      - name: npm audit (json)
        run: |
          if [ -f package.json ]; then
            npm audit --audit-level=high --json > sast-npm-audit.json
          fi
      # Загрузка артефактов, только если они существуют
      - name: Upload SAST artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sast-reports
          path: |
            gitleaks-results.sarif
            semgrep.sarif
            sast-npm-audit.json
      # Загрузка SARIF в Security tab (Gitleaks)
      - name: Upload SARIF to Security tab (Gitleaks)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gitleaks-results.sarif
      # Загрузка SARIF в Security tab (Semgrep)
      - name: Upload SARIF to Security tab (Semgrep)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif

 # ---------- Build & Push ----------
  build:
    runs-on: ubuntu-latest
    needs: sast
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    steps:
      # Клонируем репозиторий для доступа к исходному коду
      - uses: actions/checkout@v4
      # Устанавливаем Yandex Cloud CLI для работы с облаком
      - name: Install YC CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -a
          sudo install -m 0755 "$HOME/yandex-cloud/bin/yc" /usr/local/bin/yc
      # Настраиваем YC CLI с использованием секретов GitHub
      - name: Configure YC
        env:
          YC_SA_KEY_JSON: ${{ secrets.YC_SA_KEY_JSON }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          echo "$YC_SA_KEY_JSON" > sa-key.json
          yc config set service-account-key sa-key.json
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"
      # Аутентифицируемся в Yandex Container Registry
      - name: Docker login (push)
        run: |
          TOKEN=$(yc iam create-token)
          echo "$TOKEN" | docker login -u iam --password-stdin cr.yandex
      # Собираем и пушим Docker-образ в реестр
      - name: Build & Push
        id: build
        run: |
          IMAGE="${{ secrets.YC_REGISTRY_REPO }}"
          TAG="${{ github.sha }}"
          docker build \
            --build-arg DECAP_CMS_VER=3.0.9 \
            --build-arg NETLIFY_CMS_AUTH_HASH=${{ secrets.NETLIFY_CMS_AUTH_HASH }} \
            --build-arg OAUTH_CLIENT_ID=${{ secrets.OAUTH_CLIENT_ID }} \
            --build-arg OAUTH_CLIENT_SECRET=${{ secrets.OAUTH_CLIENT_SECRET }} \
            -t "$IMAGE:$TAG" -t "$IMAGE:latest" .
          docker push "$IMAGE:$TAG"
          docker push "$IMAGE:latest"
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

  # ---------- Deploy: Staging ----------
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    steps:
      # Устанавливаем Yandex Cloud CLI для работы с облаком
      - name: Install YC CLI (runner)
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -a
          sudo install -m 0755 "$HOME/yandex-cloud/bin/yc" /usr/local/bin/yc
      # Настраиваем YC CLI с использованием секретов GitHub
      - name: Configure YC (runner)
        env:
          YC_SA_KEY_JSON: ${{ secrets.YC_SA_KEY_JSON }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          echo "$YC_SA_KEY_JSON" > sa-key.json
          yc config set service-account-key sa-key.json
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"
      # Создаём IAM-токен для аутентификации в Yandex Container Registry
      - name: Create IAM token (runner)
        run: echo "YC_IAM_TOKEN=$(yc iam create-token)" >> $GITHUB_ENV
      # Деплоим Decap CMS на staging-VM через SSH
      - name: Deploy to Staging VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          envs: YC_IAM_TOKEN
          script: |
            set -euo pipefail
            echo "$YC_IAM_TOKEN" | docker login -u iam --password-stdin cr.yandex
            mkdir -p ~/decap-staging
            sudo ufw allow 80
            # Диагностика: выводим информацию о занятых портах и контейнерах
            echo "Checking port 80 and running containers..."
            ss -ltn > ~/decap-staging/port-diagnostic.log
            docker ps -a > ~/decap-staging/docker-ps.log
            # Проверяем, свободен ли порт 80
            if ss -ltn '( sport = :80 )' | grep -q LISTEN; then
              echo "ERROR: Port 80 is already in use"
              cat ~/decap-staging/port-diagnostic.log
              cat ~/decap-staging/docker-ps.log
              exit 1
            fi
            IMAGE="${{ secrets.YC_REGISTRY_REPO }}:${{ needs.build.outputs.image_tag }}"
            # Останавливаем и удаляем предыдущий деплой
            docker compose -f ~/decap-staging/docker-compose.yml down
            # Удаляем все остановленные контейнеры и сети
            docker stop $(docker ps -q) 2>/dev/null
            docker rm $(docker ps -aq) 2>/dev/null
            docker network prune -f
            # Фиксируем порт 80
            HOST_PORT=80
            export HOST_PORT
            # Создаём .env файл для контейнера
            cat > ~/decap-staging/container.env <<'ENV'
            PORT=80
            HOST=0.0.0.0
            ORIGINS=${{ secrets.STAGING_VM_HOST }}
            NODE_ENV=production
            OAUTH_CLIENT_ID=${{ secrets.OAUTH_CLIENT_ID }}
            OAUTH_CLIENT_SECRET=${{ secrets.OAUTH_CLIENT_SECRET }}
            GITHUB_CLIENT_ID=${{ secrets.OAUTH_CLIENT_ID }}
            GITHUB_CLIENT_SECRET=${{ secrets.OAUTH_CLIENT_SECRET }}
            ENV
            sed -i 's/\r$//' ~/decap-staging/container.env
            # Создаём docker-compose.yml для запуска CMS
            cat > ~/decap-staging/docker-compose.yml <<YML
            services:
              cms:
                image: ${IMAGE}
                ports:
                  - "80:80"
                restart: unless-stopped
                env_file:
                  - ./container.env
                volumes:
                  - ./config.yml:/app/config.yml:ro
                  - ./container.env:/app/.env:ro
            YML
            # Создаём config.yml для Decap CMS с настройками GitHub-бэкенда
            BASE_URL="http://${{ secrets.STAGING_VM_HOST }}"
            cat > ~/decap-staging/config.yml <<CFG
            backend:
              name: github
              repo: redsmilerus/content-repo
              branch: main
              base_url: ${BASE_URL}
              auth_endpoint: auth
              commit_messages:
                create: "Create {{collection}} “{{slug}}”"
                update: "Update {{collection}} “{{slug}}”"
                delete: "Delete {{collection}} “{{slug}}”"
                uploadMedia: "Upload “{{path}}”"
                deleteMedia: "Delete “{{path}}”"
            media_folder: /static/media/uploads
            public_folder: /media/uploads
            collections:
              - label: "Posts"
                label_singular: "Post"
                name: posts
                folder: posts
                media_folder: "/static/media/blog"
                public_folder: "../../../static/media/blog"
                slug: "{{fields.slug}}"
                path: "{{year}}/{{month}}/{{slug}}"
                create: true
                view_filters:
                  - label: Drafts
                    field: draft
                    pattern: true
                fields:
                  - { label: "Template Key", name: templateKey, widget: hidden, default: "blog-post" }
                  - { label: "Slug", name: slug, widget: string, pattern: ["^[a-z0-9]+(?:-[a-z0-9]+)*$", "A slug can have no spaces or special characters"] }
                  - { label: "Cover Image", name: cover, widget: image }
                  - { label: "Title", name: title, widget: string }
                  - { label: "Publish Date", name: date, widget: datetime }
                  - { label: "Description", name: description, widget: text }
                  - { label: "Draft", name: draft, widget: boolean, default: false }
                  - { label: "Tags", name: tags, widget: list }
                  - { label: "Body", name: body, widget: markdown }
            CFG
            docker compose -f ~/decap-staging/docker-compose.yml pull
            docker compose -f ~/decap-staging/docker-compose.yml up -d --force-recreate
            # Ждём, пока CMS запустится
            t0=$(date +%s)
            while :; do
              cid=$(docker compose -f ~/decap-staging/docker-compose.yml ps -q cms)
              logs="$(docker logs "$cid" 2>&1 | tail -n 200)"
              echo "$logs" | grep -q "Decap CMS listening on port" && break
              [ $(( $(date +%s) - t0 )) -gt 60 ] && { echo "Timeout"; echo "$logs"; exit 1; }
              sleep 2
            done
            # Сохраняем логи контейнера для отладки
            docker logs $(docker compose -f ~/decap-staging/docker-compose.yml ps -q cms) > ~/decap-staging/cms.log 2>&1
            # Проверяем локальную доступность CMS
            curl -fsSI "http://localhost:80/" >/dev/null
            docker ps
            docker logs --tail=200 "$(docker compose -f ~/decap-staging/docker-compose.yml ps -q cms)"
      # Проверяем публичную доступность CMS на порту 80
      - name: Health check (public)
        run: |
          set -e
          curl -fsSI --max-time 30 "http://${{ secrets.STAGING_VM_HOST }}/" >/dev/null
      # Загружаем диагностические логи при ошибке
      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-logs
          path: |
            ~/decap-staging/port-diagnostic.log
            ~/decap-staging/docker-ps.log
            ~/decap-staging/cms.log

  # ---------- DAST ----------
  dast:
    runs-on: ubuntu-latest
    needs: deploy-staging
    steps:
      # Запускаем ZAP для динамического анализа безопасности (DAST)
      - name: ZAP Full Scan
        uses: zaproxy/action-full-scan@v0.12.0
        with:
          target: http://${{ secrets.STAGING_VM_HOST }}/
          cmd_options: '-a -m 10'
          allow_issue_writing: false
      # Переименовываем отчёты ZAP для единообразия
      - name: Collect & normalize ZAP outputs
        run: |
          mv -f report_json.json dast-report.json
          mv -f report_html.html dast-report.html
      # Загружаем отчёты DAST как артефакты
      - name: Upload DAST reports
        uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: |
            dast-report.json
            dast-report.html

  # ---------- Image Scan ----------
  image-scan:
    runs-on: ubuntu-latest
    needs: build
    steps:
      # Устанавливаем Yandex Cloud CLI для работы с облаком
      - name: Install YC CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -a
          sudo install -m 0755 "$HOME/yandex-cloud/bin/yc" /usr/local/bin/yc
      # Настраиваем YC CLI с использованием секретов GitHub
      - name: Configure YC
        env:
          YC_SA_KEY_JSON: ${{ secrets.YC_SA_KEY_JSON }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          echo "$YC_SA_KEY_JSON" > sa-key.json
          yc config set service-account-key sa-key.json
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"
      # Аутентифицируемся в Yandex Container Registry
      - name: Docker login
        run: |
          TOKEN=$(yc iam create-token)
          echo "$TOKEN" | docker login -u iam --password-stdin cr.yandex
      # Загружаем Docker-образ для сканирования
      - name: Pull image for scanning
        run: docker pull ${{ secrets.YC_REGISTRY_REPO }}:${{ needs.build.outputs.image_tag }}
      # Сканируем Docker-образ с помощью Trivy
      - name: Trivy image scan (SARIF)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ secrets.YC_REGISTRY_REPO }}:${{ needs.build.outputs.image_tag }}
          format: sarif
          output: trivy-image.sarif
          severity: CRITICAL
          ignore-unfixed: true
          scanners: vuln
          vuln-type: library
          limit-severities-for-sarif: true
      # Выводим критические уязвимости для отладки
      - name: Show CRITICAL (debug)
        run: |
          echo "Top CRITICAL from Trivy:"
          jq -r '.runs[]?.results[]? | select(.level=="error") |
                  [.ruleId, (.message?.text // ""), (.locations[0]?.physicalLocation?.artifactLocation?.uri // "")] | @tsv' \
            trivy-image.sarif | head -n 30
      # Загружаем SARIF-отчёт Trivy в Security tab
      - name: Upload Trivy SARIF
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image.sarif
      # Загружаем отчёты сканирования образа как артефакты
      - name: Upload Image Scan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: image-scan-reports
          path: trivy-image.sarif

  # ---------- Security Gateway ----------
  security-gateway:
    runs-on: ubuntu-latest
    needs: [sast, dast, image-scan]
    env:
      TRIVY_ALLOWLIST: ${{ vars.TRIVY_ALLOWLIST }}  # "CVE-2024-1111 CVE-2023-2222"
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./_artifacts

      - name: Normalize paths
        run: |
          mkdir -p sast-reports dast-reports image-scan-reports
          cp -f _artifacts/sast-reports/* sast-reports/ 2>/dev/null || true
          cp -f _artifacts/dast-reports/* dast-reports/ 2>/dev/null || true
          cp -f _artifacts/image-scan-reports/* image-scan-reports/ 2>/dev/null || true
          [ -s sast-reports/gitleaks-results.sarif ] || echo '{"runs":[{"results":[]}]}'> sast-reports/gitleaks-results.sarif
          [ -s sast-reports/semgrep.sarif ] || echo '{"runs":[{"results":[]}]}'> sast-reports/semgrep.sarif
          [ -s sast-reports/sast-npm-audit.json ] || echo '{"metadata":{"vulnerabilities":{"info":0,"low":0,"moderate":0,"high":0,"critical":0}},"vulnerabilities":[]}' > sast-reports/sast-npm-audit.json
          [ -s dast-reports/dast-report.json ] || echo '{"site":[]}' > dast-reports/dast-report.json
          [ -s image-scan-reports/trivy-image.sarif ] || echo '{"runs":[{"results":[]}]}'> image-scan-reports/trivy-image.sarif

      - name: Check for critical vulnerabilities
        run: |
          set -e
          # Gitleaks
          if jq '.runs[0].results | length' sast-reports/gitleaks-results.sarif | grep -q '^[1-9]'; then
            echo "Gitleaks findings"; exit 1; fi
          # Semgrep
          if jq '.runs[]?.results[]? | select(.level=="error")' sast-reports/semgrep.sarif | grep -q .; then
            echo "Semgrep errors"; exit 1; fi
          # npm audit
          if jq -e '.metadata.vulnerabilities.high > 0 or .metadata.vulnerabilities.critical > 0' \
            sast-reports/sast-npm-audit.json >/dev/null; then
            echo "npm audit high/critical"; exit 1; fi
          # ZAP
          if jq '.site[]?.alerts[]? | select((.riskcode|tonumber) > 2)' dast-reports/dast-report.json | grep -q .; then
            echo "ZAP High/Critical"; exit 1; fi

          # Trivy: взять ТОЛЬКО CRITICAL из SARIF и применить allowlist
          jq -r '.runs[]?.results[]?
                  | select(.message?.text | test("Severity:\\s*CRITICAL"))
                  | .ruleId' \
            image-scan-reports/trivy-image.sarif | sort -u > _trivy_cves.txt || true

          if [ -s _trivy_cves.txt ]; then
            if [ -n "${TRIVY_ALLOWLIST:-}" ]; then
              printf "%s\n" $TRIVY_ALLOWLIST | tr ' ' '\n' | sort -u > _allow.txt
              comm -23 _trivy_cves.txt _allow.txt > _violations.txt || true
            else
              cp _trivy_cves.txt _violations.txt
            fi

            if [ -s _violations.txt ]; then
              echo "Trivy CRITICAL (not allowlisted):"
              cat _violations.txt
              exit 1
            fi
          fi

      - name: Print Trivy CRITICAL on failure
        if: failure()
        run: |
          echo "CRITICAL issues from Trivy (first 50):"
          if [ -s image-scan-reports/trivy-image.sarif ]; then
            jq -r '.runs[]?.results[]? | select(.level=="error") |
                   [.ruleId, (.message?.text // ""), (.locations[0]?.physicalLocation?.artifactLocation?.uri // "")] | @tsv' \
              image-scan-reports/trivy-image.sarif | head -n 50 || true
          else
            echo "image-scan-reports/trivy-image.sarif is missing or empty"
          fi

  # ---------- Deploy: Prod ----------
  deploy-prod:
    runs-on: ubuntu-latest
    needs: [security-gateway, build]
    if: needs.security-gateway.result == 'success'
    steps:
      - name: Install YC CLI (runner)
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -a
          sudo install -m 0755 "$HOME/yandex-cloud/bin/yc" /usr/local/bin/yc

      - name: Configure YC (runner)
        env:
          YC_SA_KEY_JSON: ${{ secrets.YC_SA_KEY_JSON }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          echo "$YC_SA_KEY_JSON" > sa-key.json
          yc config set service-account-key sa-key.json
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"

      - name: Create IAM token (runner)
        run: echo "YC_IAM_TOKEN=$(yc iam create-token)" >> $GITHUB_ENV

      - name: Deploy to Prod VM (prefer 80, fallback 8080)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          envs: YC_IAM_TOKEN
          script: |
            set -euo pipefail
            echo "$YC_IAM_TOKEN" | docker login -u iam --password-stdin cr.yandex
            mkdir -p ~/decap-prod
            sudo ufw allow 80 || true
            sudo ufw allow 8080 || true

            IMAGE="${{ secrets.YC_REGISTRY_REPO }}:${{ needs.build.outputs.image_tag }}"
            case "$IMAGE" in *:) echo "Image tag is empty — check needs.build.outputs.image_tag"; exit 1;; esac

            # Если уже развернут — освободим порт и обновим
            docker compose -f ~/decap-prod/docker-compose.yml down || true

            HOST_PORT=80
            if ss -ltn '( sport = :80 )' 2>/dev/null | grep -q LISTEN; then
              echo "WARNING: 80 is busy; using 8080 (проверь совместимость OAuth)."
              HOST_PORT=8080
            fi
            export HOST_PORT

            # env для контейнера (prod)
            cat > ~/decap-prod/container.env <<'ENV'
            PORT=80
            HOST=0.0.0.0
            # ORIGINS — только хост, без http:// и без :порт
            ORIGINS=${{ secrets.VM_HOST }}

            NODE_ENV=production

            # OAuth for GitHub (runtime)
            OAUTH_CLIENT_ID=${{ secrets.OAUTH_CLIENT_ID }}
            OAUTH_CLIENT_SECRET=${{ secrets.OAUTH_CLIENT_SECRET }}

            # Дубли для некоторых провайдеров:
            GITHUB_CLIENT_ID=${{ secrets.OAUTH_CLIENT_ID }}
            GITHUB_CLIENT_SECRET=${{ secrets.OAUTH_CLIENT_SECRET }}
            ENV
            sed -i 's/\r$//' ~/decap-prod/container.env

            # docker-compose с подстановкой HOST_PORT
            cat > ~/decap-prod/docker-compose.yml <<'YML'
            services:
              cms:
                image: __IMAGE__
                ports:
                  - "${HOST_PORT}:80"
                restart: unless-stopped
                env_file:
                  - ./container.env
                volumes:
                  - ./config.yml:/app/config.yml:ro
                  - ./container.env:/app/.env:ro
            YML
            sed -i "s|__IMAGE__|${IMAGE}|g" ~/decap-prod/docker-compose.yml
            export HOST_PORT

            # base_url c учётом порта
            BASE_URL="http://${{ secrets.VM_HOST }}"
            if [ "$HOST_PORT" != "80" ]; then BASE_URL="${BASE_URL}:${HOST_PORT}"; fi

            # config.yml
            cat > ~/decap-prod/config.yml <<CFG
            backend:
              name: github
              repo: redsmilerus/content-repo
              branch: main
              base_url: ${BASE_URL}
              auth_endpoint: auth
              commit_messages:
                create: "Create {{collection}} “{{slug}}”"
                update: "Update {{collection}} “{{slug}}”"
                delete: "Delete {{collection}} “{{slug}}”"
                uploadMedia: "Upload “{{path}}”"
                deleteMedia: "Delete “{{path}}”"
            media_folder: /static/media/uploads
            public_folder: /media/uploads
            collections:
              - label: "Posts"
                label_singular: "Post"
                name: posts
                folder: posts
                media_folder: "/static/media/blog"
                public_folder: "../../../static/media/blog"
                slug: "{{fields.slug}}"
                path: "{{year}}/{{month}}/{{slug}}"
                create: true
                view_filters:
                  - label: Drafts
                    field: draft
                    pattern: true
                fields:
                  - { label: "Template Key", name: templateKey, widget: hidden, default: "blog-post" }
                  - { label: "Slug", name: slug, widget: string, pattern: ["^[a-z0-9]+(?:-[a-z0-9]+)*$", "A slug can have no spaces or special characters"] }
                  - { label: "Cover Image", name: cover, widget: image }
                  - { label: "Title", name: title, widget: string }
                  - { label: "Publish Date", name: date, widget: datetime }
                  - { label: "Description", name: description, widget: text }
                  - { label: "Draft", name: draft, widget: boolean, default: false }
                  - { label: "Tags", name: tags, widget: list }
                  - { label: "Body", name: body, widget: markdown }
            CFG

            docker compose -f ~/decap-prod/docker-compose.yml pull
            HOST_PORT=$HOST_PORT docker compose -f ~/decap-prod/docker-compose.yml up -d --force-recreate

            # Ожидание готовности
            t0=$(date +%s)
            while :; do
              cid=$(docker compose -f ~/decap-prod/docker-compose.yml ps -q cms || true)
              logs="$(docker logs "$cid" 2>&1 | tail -n 200 || true)"
              echo "$logs" | grep -q "Decap CMS listening on port" && break || true
              [ $(( $(date +%s) - t0 )) -gt 60 ] && { echo "Timeout"; echo "$logs"; exit 1; }
              sleep 2
            done

            # Локальный health
            curl -fsSI "http://localhost:${HOST_PORT}/" >/dev/null || \
            curl -fsSL "http://localhost:${HOST_PORT}/#/" >/dev/null

            docker ps
            docker logs --tail=200 "$(docker compose -f ~/decap-prod/docker-compose.yml ps -q cms)" || true

      - name: Health check (public)
        run: |
          set -e
          curl -fsSI --max-time 30 "http://${{ secrets.VM_HOST }}/" >/dev/null || \
          curl -fsSL --max-time 30 "http://${{ secrets.VM_HOST }}/#/" >/dev/null || \
          curl -fsSI --max-time 30 "http://${{ secrets.VM_HOST }}:8080/" >/dev/null || \
          curl -fsSL --max-time 30 "http://${{ secrets.VM_HOST }}:8080/#/" >/dev/null
